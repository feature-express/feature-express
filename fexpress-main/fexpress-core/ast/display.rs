use crate::ast::core::Expr;
use std::fmt::{Display, Formatter};

impl Display for Expr {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Expr::FullQuery(full_query) => write!(f, "{}", full_query),
            Expr::EventType => write!(f, "event_type"),
            Expr::EventTime => write!(f, "event_time"),
            Expr::EventId => write!(f, "event_id"),
            Expr::ObservationDate => write!(f, "obs_dt"),
            Expr::EntityId(id) => write!(f, "entities.{}", id.0),
            Expr::AttrBool(_) => unimplemented!(),
            Expr::AttrNum(_) => unimplemented!(),
            Expr::AttrInt(_) => unimplemented!(),
            Expr::AttrStr(_) => unimplemented!(),
            Expr::AttrMapNum(_) => unimplemented!(),
            Expr::AttrMapStr(_) => unimplemented!(),
            Expr::AttrVecStr(_) => unimplemented!(),
            Expr::AttrVecInt(_) => unimplemented!(),
            Expr::AttrVecNum(_) => unimplemented!(),
            Expr::AttrVecBool(_) => unimplemented!(),
            Expr::AttrDate(_) => unimplemented!(),
            Expr::AttrDateTime(_) => unimplemented!(),
            Expr::AttrUntyped(a) => write!(f, "{}", a),
            Expr::ContextAttr(a) => write!(f, "@{}", a),
            Expr::None => write!(f, "null"),
            Expr::Wildcard => write!(f, "*"),
            Expr::LitBool(v) => write!(f, "{}", v),
            Expr::LitNum(v) => write!(f, "{}", v),
            Expr::LitInt(v) => write!(f, "{}", v),
            Expr::LitStr(v) => write!(f, "{}", v),
            Expr::LitDate(v) => write!(f, "{}", v),
            Expr::LitDateTime(v) => write!(f, "{}", v),
            Expr::TupleLitBool(v) => write!(f, "{:?}", v),
            Expr::TupleLitNum(v) => write!(f, "{:?}", v),
            Expr::TupleLitInt(v) => write!(f, "{:?}", v),
            Expr::TupleLitStr(v) => write!(f, "{:?}", v),
            Expr::Cons(a, b) => write!(f, "({},{})", *a, *b),
            Expr::Add(a, b) => write!(f, "({} + {})", *a, *b),
            Expr::Sub(a, b) => write!(f, "({} - {})", *a, *b),
            Expr::Mul(a, b) => write!(f, "({} * {})", *a, *b),
            Expr::Div(a, b) => write!(f, "({} / {})", *a, *b),
            Expr::Eq(a, b) => write!(f, "({} = {})", *a, *b),
            Expr::Neq(a, b) => write!(f, "({} != {})", *a, *b),
            Expr::GreaterEq(a, b) => write!(f, "({} >= {})", *a, *b),
            Expr::LessEq(a, b) => write!(f, "({} <= {})", *a, *b),
            Expr::Greater(a, b) => write!(f, "({} > {})", *a, *b),
            Expr::Less(a, b) => write!(f, "({} < {})", *a, *b),
            Expr::And(a, b) => write!(f, "({} and {})", *a, *b),
            Expr::Or(a, b) => write!(f, "({} or {})", *a, *b),
            Expr::Not(v) => write!(f, "{}", *v),
            Expr::In(a, b) => write!(f, "{} in {}", *a, *b),
            Expr::NotIn(a, b) => write!(f, "{} not in {}", *a, *b),
            Expr::Aggr(v) => write!(f, "{:}", v),
            Expr::Having(v) => write!(f, "{:}", v),
            Expr::Alias(_a, v) => write!(f, "{}", v),
            Expr::VariableAssign(a, b) => write!(f, "{}:={}", a, b),
            Expr::Select(v) => write!(f, "{}", v),
            Expr::Function(v) => write!(f, "{}", v),
            Expr::ParsingError(v) => write!(f, "{}", v),
        }
    }
}
