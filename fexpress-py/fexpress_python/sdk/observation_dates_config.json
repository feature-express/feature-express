{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ObservationDatesConfig",
  "description": "We can provide observation dates either as a generator or an explicit map of entity -> timestamps When it comes to observation dates they are very important from the standpoint of feature engineering in general. Basically what we have here are 2 ways of looking at the problem\n\n1) Entity-based - We want to model things independently on events. For example a customer that does transactions is not a regular time-series generator but more sparse type of data. In cases like these we are just saying. Pick some dates throughout the customer history and try to predict things into the future\n\n2) Event-based - We want to model things that are the events themselves - or at least they are avaiable in the evaluation context.",
  "oneOf": [
    {
      "type": "string",
      "enum": [
        "AllEvents"
      ]
    },
    {
      "type": "object",
      "required": [
        "Interval"
      ],
      "properties": {
        "Interval": {
          "$ref": "#/definitions/Interval"
        }
      },
      "additionalProperties": false
    },
    {
      "type": "object",
      "required": [
        "Fixed"
      ],
      "properties": {
        "Fixed": {
          "$ref": "#/definitions/Fixed"
        }
      },
      "additionalProperties": false
    },
    {
      "type": "object",
      "required": [
        "EntitySpecific"
      ],
      "properties": {
        "EntitySpecific": {
          "$ref": "#/definitions/EntitySpecific"
        }
      },
      "additionalProperties": false
    },
    {
      "type": "object",
      "required": [
        "AllEventsByEntity"
      ],
      "properties": {
        "AllEventsByEntity": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        }
      },
      "additionalProperties": false
    },
    {
      "type": "object",
      "required": [
        "ConditionalEvents"
      ],
      "properties": {
        "ConditionalEvents": {
          "$ref": "#/definitions/ConditionalEvents"
        }
      },
      "additionalProperties": false
    },
    {
      "type": "object",
      "required": [
        "EntitiesEventSpecific"
      ],
      "properties": {
        "EntitiesEventSpecific": {
          "$ref": "#/definitions/EntitiesEventSpecific"
        }
      },
      "additionalProperties": false
    }
  ],
  "definitions": {
    "ConditionalEvents": {
      "description": "This type of observation dates means that the observation dates are based on a specific condition based on the where clause applied to the [Event]. Probably the proper way to handle this type of thing. Is that the user provides the where clause and we only compile it when we need to calculate the features.",
      "type": "object",
      "required": [
        "condition",
        "entity_types"
      ],
      "properties": {
        "condition": {
          "type": "string"
        },
        "entity_types": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        }
      }
    },
    "DatePart": {
      "type": "string",
      "enum": [
        "Millisecond",
        "Second",
        "Minute",
        "Hour",
        "Day",
        "Week",
        "All"
      ]
    },
    "EntitiesEventSpecific": {
      "description": "This struct represents the choice of specific events that will serve as the source for the observation dates and also be a source of the event.",
      "type": "object",
      "required": [
        "dates"
      ],
      "properties": {
        "dates": {
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "array",
              "items": [
                {
                  "type": "string",
                  "format": "partial-date-time"
                },
                {
                  "type": "string"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            }
          }
        }
      }
    },
    "EntitySpecific": {
      "type": "object",
      "required": [
        "dates"
      ],
      "properties": {
        "dates": {
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/ObservationTime"
            }
          }
        }
      }
    },
    "Fixed": {
      "type": "object",
      "required": [
        "dates",
        "entity_types"
      ],
      "properties": {
        "dates": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "partial-date-time"
          }
        },
        "entity_types": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        }
      }
    },
    "Interval": {
      "type": "object",
      "required": [
        "date_part",
        "entity_types",
        "nth"
      ],
      "properties": {
        "date_part": {
          "$ref": "#/definitions/DatePart"
        },
        "entity_types": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        },
        "nth": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "ObservationTime": {
      "type": "object",
      "required": [
        "datetime"
      ],
      "properties": {
        "datetime": {
          "type": "string",
          "format": "partial-date-time"
        },
        "event_id": {
          "type": [
            "string",
            "null"
          ]
        }
      }
    }
  }
}